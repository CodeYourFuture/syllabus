"use strict";(self.webpackChunkcodeyourfuture_syllabus=self.webpackChunkcodeyourfuture_syllabus||[]).push([[9728],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=u(n),p=a,m=d["".concat(l,".").concat(p)]||d[p]||h[p]||s;return n?o.createElement(m,r(r({ref:t},c),{},{components:n})):o.createElement(m,r({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,r[1]=i;for(var u=2;u<s;u++)r[u]=n[u];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},87026:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return h}});var o=n(87462),a=n(63366),s=(n(67294),n(3905)),r=["components"],i={},l="More Uses of Node.js for SQL",u={unversionedId:"xtras/extra-node/extra-node",id:"xtras/extra-node/extra-node",title:"More Uses of Node.js for SQL",description:"Node and PostgreSQL Authentication",source:"@site/docs/xtras/extra-node/extra-node.md",sourceDirName:"xtras/extra-node",slug:"/xtras/extra-node/",permalink:"/xtras/extra-node/",draft:!1,editUrl:"https://github.com/CodeYourFuture/Syllabus-V2/edit/master/docs/xtras/extra-node/extra-node.md",tags:[],version:"current",frontMatter:{}},c={},h=[{value:"Node and PostgreSQL Authentication",id:"node-and-postgresql-authentication",level:2},{value:"Separate the PostgreSQL Authorisation Details",id:"separate-the-postgresql-authorisation-details",level:3},{value:"Use Sytem Environmemt Variables",id:"use-sytem-environmemt-variables",level:3},{value:"Understanding Connections to PostgreSQL",id:"understanding-connections-to-postgresql",level:2},{value:"Using a Single Connection for Multiple SQL Commands",id:"using-a-single-connection-for-multiple-sql-commands",level:2},{value:"Exercise:",id:"exercise",level:3},{value:"Understanding Synchronous and Asynchronous Computing",id:"understanding-synchronous-and-asynchronous-computing",level:2},{value:"Synchronous vs Asynchronous",id:"synchronous-vs-asynchronous",level:3},{value:"Why Does JavaScript Prefer Asynchronous I/O?",id:"why-does-javascript-prefer-asynchronous-io",level:3},{value:"How Does JavaScript Handle Queued Requests?",id:"how-does-javascript-handle-queued-requests",level:3},{value:"Using async/await for Complex Database Activity",id:"using-asyncawait-for-complex-database-activity",level:2},{value:"Transactions in Node",id:"transactions-in-node",level:2}],d={toc:h};function p(e){var t=e.components,i=(0,a.Z)(e,r);return(0,s.kt)("wrapper",(0,o.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"more-uses-of-nodejs-for-sql"},"More Uses of Node.js for SQL"),(0,s.kt)("h2",{id:"node-and-postgresql-authentication"},"Node and PostgreSQL Authentication"),(0,s.kt)("p",null,"So far we have used a very insecure method to log on to our database server. All the connection an login details have bee stored in plain text in the code of our server.js file. If we use a service such as github to manage our code then the details are open to the entire internet."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const db = new Pool({\n  user: "keith",\n  host: "localhost",\n  database: "cyf_hotel",\n  password: "?????",\n  port: 5432,\n});\n')),(0,s.kt)("p",null,"There are other ways to accomplish the same connection but without making the details public."),(0,s.kt)("h3",{id:"separate-the-postgresql-authorisation-details"},"Separate the PostgreSQL Authorisation Details"),(0,s.kt)("p",null,"In this approach you put the database connection information into a separate file and include it into your server.js:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'// credentials.js\nconst credentials = {\n  user: "keith",\n  host: "localhost",\n  database: "cyf_hotel",\n  password: "?????",\n  port: 5432,\n};\nmodule.exports = credentials;\n')),(0,s.kt)("p",null,"Then, in server.js you can include the ",(0,s.kt)("inlineCode",{parentName:"p"},"credentials.js")," file and use the details to define your ",(0,s.kt)("inlineCode",{parentName:"p"},"db")," Pool:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// server.js\n...\nconst credentials = require('./credentials.js');\n\nconst db = new Pool(credentials);\n...\n")),(0,s.kt)("p",null,"The next very important thing to do is ensure that your ",(0,s.kt)("inlineCode",{parentName:"p"},"credentials.js")," file is not included in your source control system, e.g. add it to your ",(0,s.kt)("inlineCode",{parentName:"p"},".gitignore")," file so that it does not get versioned and pushed to github."),(0,s.kt)("h3",{id:"use-sytem-environmemt-variables"},"Use Sytem Environmemt Variables"),(0,s.kt)("p",null,"Another approach is to provide all the database connection and authorisation details via environment variables. Since these are done differently on different platforms we provide only the Linux/Unix style for achieving this."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"export PGUSER=keith \\\n    PGHOST=localhost \\\n    PGDATABASE=cyf_hotel \\\n    PGPASSWORD=????? \\\n    PGPORT=5432 \\\n    node server.js\n")),(0,s.kt)("p",null,"Note: This is a single command and could be typed on one line (without the continuation character ",(0,s.kt)("inlineCode",{parentName:"p"},"\\"),")."),(0,s.kt)("p",null,"The node-postgres package will automatically use the environment variables to provide the connection details. In ",(0,s.kt)("inlineCode",{parentName:"p"},"server.js")," you now just use:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const db = new Pool();\n")),(0,s.kt)("p",null,"Even this approach has some security issues because some operating systems allow other users to see your environment variables. To ensure that the password is completely secure you should use the ",(0,s.kt)("inlineCode",{parentName:"p"},".pgpass")," file in your home directory (or, on Windows, ",(0,s.kt)("inlineCode",{parentName:"p"},"%APPDATA%\\postgresql\\pgpass.conf"),")."),(0,s.kt)("p",null,"This file has contents formatted as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"# Password file formatted as:\n# hostname:port:database:username:password\n#\nlocalhost:5432:cyf_hotel:keith:mysecretpassword\n*:*:*:postgres:pgsuperpass\n")),(0,s.kt)("p",null,"This file is matched, line by line, with the host, port, database and user used by the connection until a match is found. The password from that line is used. Note that ",(0,s.kt)("inlineCode",{parentName:"p"},"*")," is a wildcard and matches anything and can be used in the any of the first four fields."),(0,s.kt)("p",null,"When using this file:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"You should not provide the PGPASSWORD environment variable"),(0,s.kt)("li",{parentName:"ul"},"The file must only be readable by you - on ","*","nix use ",(0,s.kt)("inlineCode",{parentName:"li"},"chmod 0600 .pgpass")),(0,s.kt)("li",{parentName:"ul"},"You can override the file name using the PGPASSFILE environment variable")),(0,s.kt)("h2",{id:"understanding-connections-to-postgresql"},"Understanding Connections to PostgreSQL"),(0,s.kt)("p",null,"So far in the CYF course we have used the ",(0,s.kt)("inlineCode",{parentName:"p"},"db.query")," method for executing SQL. By using ",(0,s.kt)("inlineCode",{parentName:"p"},"db.query")," the server opens a new connection, executes the query then closes the connection. This is fine for a single SQL command but is inefficient or simply won't work for more complex situations that involve multiple SQL commands."),(0,s.kt)("p",null,"Just to recap, we used the following preamble to configure our server to use express, bodyparser and postgres:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const express = require("express");\nconst bodyParser = require("body-parser");\n\nconst app = express();\n\nconst Pool = require("pg").Pool;\n\nconst db = new Pool(); // Assuming use of environment variables for authorisation\n\napp.use(bodyParser.json());\n')),(0,s.kt)("p",null,"All of this is still required."),(0,s.kt)("p",null,"We also defined an endpoint to handle POST requests to insert a new customer, first checking that the customer's email is not already in the database:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'//\n// Route to add a new customer\n//\napp.post("/customers", function (req, res) {\n  const custName = req.body.name;\n  const custEmail = req.body.email;\n  const custPhone = req.body.phone;\n  if (\n    custPhone.replace(/[\\+\\-\\(\\)0-9 ]/g, "0") !=\n    "0".padEnd(custPhone.length, "0")\n  ) {\n    return res\n      .status(400)\n      .send("Phone number can contain only 0-9, +, -, (, ) or space.");\n  }\n  //\n  // Check the customer\'s email isn\'t already in the table\n  //\n  db.query(\n    "SELECT 1 FROM customers WHERE email=$1",\n    [custEmail],\n    (err, result) => {\n      if (result.rows.length > 0) {\n        //\n        // The email already exists in the table so return an error\n        //\n        return res\n          .status(400)\n          .send("A customer with that email address already exists!");\n      } else {\n        //\n        // The email is not in the table so insert the new customer\n        //\n        db.query(\n          "INSERT INTO customers (name, email, phone) " +\n            "VALUES ($1, $2, $3) " +\n            "RETURNING id",\n          [custName, custEmail, custPhone],\n          (err, result) => {\n            if (err == undefined) {\n              let newId = result.rows[0].id;\n              res.send(`New customer added with id = ${newId}.`);\n            } else {\n              res.status(500).json({ error: err });\n            }\n          }\n        );\n      }\n    }\n  );\n});\n')),(0,s.kt)("p",null,"Because this uses ",(0,s.kt)("inlineCode",{parentName:"p"},"db.query")," twice, once to check the email is not present and again to insert the new customer, it requires two separate connections to the database, one for each ",(0,s.kt)("inlineCode",{parentName:"p"},"db.query"),". Since connections are expensive to acquire it makes sense to try to reduce them if possible, which we can do in this case."),(0,s.kt)("h2",{id:"using-a-single-connection-for-multiple-sql-commands"},"Using a Single Connection for Multiple SQL Commands"),(0,s.kt)("p",null,"Instead of using ",(0,s.kt)("inlineCode",{parentName:"p"},"db.query")," for each SQL command we first of all establish a connection:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"  db.connect((err, conn, release) => { ... });\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"db.connect")," method uses a callback function with three arguments, ",(0,s.kt)("inlineCode",{parentName:"p"},"(err, conn, release)"),"."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"err")," argument is as before, it is either undefined if no error occurred or an appropiate message if the connection failed."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"conn")," argument takes the connection information and makes it available for the duration of the callback function with methods such as ",(0,s.kt)("inlineCode",{parentName:"p"},"conn.query"),", which is very similar to the ",(0,s.kt)("inlineCode",{parentName:"p"},"db.query")," method we've used before but doesn't establish its own connection, it uses the one we've created using ",(0,s.kt)("inlineCode",{parentName:"p"},"db.connect"),"."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"release")," argument takes as its value a function that will release the connection when no longer needed."),(0,s.kt)("p",null,"As before, all the work is done within the callback function using multiple invocations of the ",(0,s.kt)("inlineCode",{parentName:"p"},"conn.query")," method to execute SQL but this time using just the one connection. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'...\napp.post("/customers", function(req, res) {\n  const custName = req.body.name;\n  const custEmail = req.body.email;\n  const custPhone = req.body.phone;\n  // ... Omitted the code to check the phone number to simplify the example\n  db.connect((err, conn, release) => {\n    conn.query("SELECT 1 FROM customers WHERE email=$1", [custEmail],\n            (err, result) => {\n      if (result.rowCount > 0) {\n        release();\n        return res\n          .status(400)\n          .send("A customer with that email address already exists!");\n      } else {\n        conn.query("INSERT INTO customers (name, email, phone) " +\n                "VALUES ($1, $2, $3) " +\n                "RETURNING id", [custName, custEmail, custPhone],\n          (err, result) => {\n            if (err == undefined) {\n              let newId = result.rows[0].id;\n              release();\n              res.send(`New customer added with id = ${newId}.`);\n            } else {\n              release();\n              res.status(500).json({error: err});\n            }\n        });\n      }\n    });\n  });\n});\n')),(0,s.kt)("p",null,"Notice that in this example we're using ",(0,s.kt)("inlineCode",{parentName:"p"},"conn.query")," instead of ",(0,s.kt)("inlineCode",{parentName:"p"},"db.query")," but the rest of the code is very similar to the previous example."),(0,s.kt)("p",null,"You may have noticed the addition of a few calls of the ",(0,s.kt)("inlineCode",{parentName:"p"},"release()")," function - these are important. You must call ",(0,s.kt)("inlineCode",{parentName:"p"},"release()")," to release a connection you have established using ",(0,s.kt)("inlineCode",{parentName:"p"},"db.connect")," otherwise you could exhaust the pool of available connections. The above code calls ",(0,s.kt)("inlineCode",{parentName:"p"},"release()")," at every point where the endpoint could exit."),(0,s.kt)("p",null,"So now you have learned how to use a single connection and how to release it when finished."),(0,s.kt)("h3",{id:"exercise"},"Exercise:"),(0,s.kt)("p",null,"We can use the server.js that you wrote for the CYF DB Module or you can start with a new node environment completely - it's your choice."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Ensure your server.js file has the appropriate preamble to initialise Express, Body Parser and PostgreSQL. You can use the cyf_hotel database created as part of the previous course."),(0,s.kt)("li",{parentName:"ol"},"Rewrite the ",(0,s.kt)("inlineCode",{parentName:"li"},"POST")," endpoint for ",(0,s.kt)("inlineCode",{parentName:"li"},"/customers")," that inserts new customer data so that it uses a single connection for both checking the email and inserting the new customer."),(0,s.kt)("li",{parentName:"ol"},"Create a new ",(0,s.kt)("inlineCode",{parentName:"li"},"PUT")," endpoint for updating a customer's email address but include a check that the new email address doesn't exist in the customers table already.")),(0,s.kt)("h2",{id:"understanding-synchronous-and-asynchronous-computing"},"Understanding Synchronous and Asynchronous Computing"),(0,s.kt)("h3",{id:"synchronous-vs-asynchronous"},"Synchronous vs Asynchronous"),(0,s.kt)("p",null,"In synchronous code each step completes fully before moving on to the next step. In JavaScript this is normal for operations that act only on memory and don't involve any input or output. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const limit = 1000;\nlet step = 1;\nlet total = 0;\nfor (let i = 1; i <= limit; i += step) {\n  total += i;\n  step++;\n}\n")),(0,s.kt)("p",null,'These synchronous operations effectively "block" the execution of subsequent steps until the operation is complete. For in-memory operations, such as manipulating variables, these operations are very fast so blocking is short-lived, lasting only micro-seconds. In any case, the requirements of an algorithm will usually require that preceding operations complete before subsequent operations can take place.'),(0,s.kt)("p",null,"For operations that involve some kind of input or output (for example, reading a file, sending a request over a network) the input/output (I/O) operations are normally processed asynchronously. These operations are much slower than in-memory actions, usually taking milli-seconds or longer to complete. The input/output operation simply adds a request to perform this operation onto a queue of operations. Following code continues to execute immediately after the request has been queued. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'function my_callback(err, result) {\n  if (err == undefined) {\n    console.log("Result = ", result); // process the result of the query\n    // in the callback function\n  }\n}\n\ndb.query("SELECT * FROM rooms WHERE room_no = 123", my_callback(err, result)); // I/O operation queues request\n\nconsole.log("Query has been queued"); // executes immediately after db.query sends the request\n')),(0,s.kt)("p",null,"This will result in the output:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Query has been queued\nResult = {...}\n")),(0,s.kt)("p",null,"Notice that the message produced in the callback function will invariably appear after the message produced immediately after sending the query to the database."),(0,s.kt)("h3",{id:"why-does-javascript-prefer-asynchronous-io"},"Why Does JavaScript Prefer Asynchronous I/O?"),(0,s.kt)("p",null,"Firstly it's important to understand that JavaScript was originally developed as a language to be used in the browser environment. A user might initiate an action in the browser that takes some time then decide to cancel it. In order to activate another element (e.g. link, button,...) to perform the cancel operation the browser must respond to an event. It must not be blocked by an earlier operation that has not yet completed."),(0,s.kt)("p",null,'Because JavaScript is "single-threaded", blocking the execution could potentially lock up the entire web page, hence the preference for asynchronous I/O.'),(0,s.kt)("p",null,'"But," you argue, "we are using node as a server, not in a web page". The trouble is that making the behaviour of node different from the browser would require a complete re-working of JavaScript, so we have to conform to the same rules. Even in the server environment we must use asynchronous I/O to prevent the whole server from becoming blocked.'),(0,s.kt)("h3",{id:"how-does-javascript-handle-queued-requests"},"How Does JavaScript Handle Queued Requests?"),(0,s.kt)("p",null,"This is a rather long and complicated story, but essentially it works a bit like the following:\nA looping process looks at the queue of requests:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"If a request is ready on the queue, remove it from the quque (de-queue the request)"),(0,s.kt)("li",{parentName:"ol"},'Assign the request to an available "non-blocking worker" thread'),(0,s.kt)("li",{parentName:"ol"},"Go back to step 1")),(0,s.kt)("p",null,"The worker thread will then:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Process the request (e.g. send it to the database server)"),(0,s.kt)("li",{parentName:"ol"},"Wait for the results from the request (e.g. rows from the database)",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"(Note the worker thread IS blocked until the results arrive)"))),(0,s.kt)("li",{parentName:"ol"},"Add the results to another queue (results queue)"),(0,s.kt)("li",{parentName:"ol"},"Signal completion of the request"),(0,s.kt)("li",{parentName:"ol"},"Wait for another request")),(0,s.kt)("p",null,"When the completion signal is received JavaScript executes the callback function of the request-making call and returns the results from the queue."),(0,s.kt)("p",null,"This is a rather simplified and loosely described process but it captures the essential features."),(0,s.kt)("h2",{id:"using-asyncawait-for-complex-database-activity"},"Using async/await for Complex Database Activity"),(0,s.kt)("p",null,"We've only had fairly simple endpoints so far in our use of the database. A ",(0,s.kt)("inlineCode",{parentName:"p"},"GET")," endpoint to return all or selected customers, a ",(0,s.kt)("inlineCode",{parentName:"p"},"POST"),' endpoint to insert a new customer, and so forth. In each of these there are only a few SQL commands, each of which involves a callback function. When the endpoint gets more complex with the number of SQL commands increasing then the corresponding callback functions can become very ugly and difficult to manage (known as "callback hell").'),(0,s.kt)("p",null,'One elegant and easy way to overcome this is to use the Javascript async/await capability. You may have used async/await in previous sessions but we can provide the basics again here. Remember that async/await uses promises but makes the code structure much simpler (more like a "conventional" programming language) by hiding the asynchronous parts. We also use the ',(0,s.kt)("inlineCode",{parentName:"p"},"try/catch")," construct to handle errors, simplifying error handling too."),(0,s.kt)("p",null,"First of all the ",(0,s.kt)("inlineCode",{parentName:"p"},"await")," mechanism can only be used inside a function declared as ",(0,s.kt)("inlineCode",{parentName:"p"},"async"),", so:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"async function doSomething() {\n  // await code can go in here...\n}\n")),(0,s.kt)("p",null,'Another way to do this, especially useful in a Node/Express endpoint, is to use an "Immediately Invoked Function Expression" or IIFE (you can look this up on the web...). In a node/express endpoint this would look like:'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'app.post("/customer", (req, res) => {\n  ... // initialise endpoint stuff here...\n  (async function() {           // here\'s the IIFE syntax for the function\n    ...               // database stuff here using await ...\n  })();                         // notice the () after the closing parenthesis )\n});\n')),(0,s.kt)("p",null,"Things to notice about the above:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The endpoint is just a normal endpoint - the endpoint address is not important here"),(0,s.kt)("li",{parentName:"ol"},"Enclose the entire async function expression in parentheses"),(0,s.kt)("li",{parentName:"ol"},"Put an empty pair of parentheses after the enclosing ()'s")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"  (async function() { ... })();\n")),(0,s.kt)("p",null,"Note: Very carefully go through the above line of code checking the parentheses - which ones match?"),(0,s.kt)("p",null,"Now, let's do some real work in that endpoint. We'll do the same things that happened in our callback version but use ",(0,s.kt)("inlineCode",{parentName:"p"},"await")," instead:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'app.post("/customers", function(req, res) {\n  const custName = req.body.name;\n  const custEmail = req.body.email;\n  const custPhone = req.body.phone;\n  ...\n\n  (async () => {      // Yes, we can use the arrow function notation\n    try {\n      let result;\n\n      const conn = await db.connect();\n      result = await conn.query("SELECT 1 FROM customers WHERE email=$1", [custEmail]);\n      if (result.rowCount > 0) {\n        await conn.release();\n        return res\n          .status(400)\n          .send("A customer with that email address already exists!");\n      } else {\n        result = await conn.query("INSERT INTO customers (name, email, phone) " +\n                          "VALUES ($1, $2, $3) " +\n                          "RETURNING id", [custName, custEmail, custPhone]);\n        let newId = result.rows[0].id;\n        await conn.release();\n        res.send(`New customer added with id = ${newId}.`);\n      }\n    } catch(err) {\n      await conn.release();\n      res.status(500).json({error: err});\n    }\n  })();\n});\n')),(0,s.kt)("p",null,"If you compare the above with the callback version of the same thing you'll notice:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A simpler code structure to the whole endpoint, which can become very significant in complex cases"),(0,s.kt)("li",{parentName:"ul"},"The use of ",(0,s.kt)("inlineCode",{parentName:"li"},"try {...} catch ...")," to handle errors, saving a lot of effort.")),(0,s.kt)("p",null,"The above example involves just two SQL commands and doesn't require a transaction as it just performs a simple INSERT. In more complex cases where several tables need changes then transactions can be used and are often essential to avoid inconsistencies."),(0,s.kt)("h2",{id:"transactions-in-node"},"Transactions in Node"),(0,s.kt)("p",null,"In order to use a transaction in Node we must use ",(0,s.kt)("inlineCode",{parentName:"p"},"BEGIN TRANSACTION"),", the insert/update/delete commands and the ",(0,s.kt)("inlineCode",{parentName:"p"},"COMMIT")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"ROLLBACK")," to terminate it, at least three SQL commands in all but usually rather more. We must also use a single connection for all these so must use the above scheme of working."),(0,s.kt)("p",null,"Consider the situation when a customer checks in to our hotel and is assigned a room and has their room billing initialised by creating an invoice. The customer can optionally request a change to their checkout date at the same time. This requires an update to the reservation and the insert of an invoice record. We can do this as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'app.put("/reservations/checkin/:id", function (req, res) {\n  const resId = req.params.id;\n  const resRoomNo = req.body.room_no;\n  const resCheckout = req.body.checkout_date; // customer can amend checkout date on arrival\n\n  (async () => {\n    try {\n      const conn = await db.connect();\n      await conn.query("BEGIN TRANSACTION");\n      if (resCheckout === undefined) {\n        await conn.query(\n          "UPDATE reservations" + " SET room_no = $2" + " WHERE id = $1",\n          [resId, resRoomNo]\n        );\n      } else {\n        await conn.query(\n          "UPDATE reservations" +\n            " SET room_no = $2, checkout_date = $3" +\n            " WHERE id = $1",\n          [resId, resRoomNo, resCheckout]\n        );\n      }\n      await conn.query(\n        "INSERT INTO invoices (res_id, total)" + " VALUES ($1, 0.0)",\n        [resId]\n      );\n      await conn.query("COMMIT");\n      await conn.release();\n      res.status(200).send("Checkin completed successfully");\n    } catch (err) {\n      if (conn != null) {\n        await conn.query("ROLLBACK");\n        await conn.release();\n      }\n      res.status(500).json({ error: err });\n    }\n  })();\n});\n')),(0,s.kt)("p",null,"That is how to do a very basic transaction in Node.js but it misses an important consideration. If our application is intended to be used by multiple users, some of whom may be online over the web, then we cannot safely leave it as it is. In particular there is the potential for users to make conflicting updates and destroy each other's work."),(0,s.kt)("p",null,"The problem arises in the time spent by the user checking and making the changes on their screen. They've just queried to see the customer's details and reservation, they assign a room number and ask if the customer wishes to change the checkout date. They type in the relevant details to confirm the checkin. In the time between their initial query and getting to this point another user could make a change to the same data. Whoever hits the 'Submit' button first will lose their changes as the second user overwrites them when they press 'Submit'."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Change Conflict Diagram",src:n(32898).Z,width:"612",height:"522"})),(0,s.kt)("p",null,"There are two ways to deal with this. We could lock the relevant row(s) when a user queries the initial data (e.g. customer and reservation details) but this could cause concurrency problems and is also not possible in a web-based application. In order to hold a lock we must retain the same connection session on the database but node releases the connection as it returns to the user."),(0,s.kt)("p",null,'The second way is to use what is called "optimistic locking". We only lock the records to be updated after the user has submitted their changes. This approach requires some extra processing, in particular we need to be sure the data to be changed hasn\'t been modified by another user since the original query. There are two main ways to do this:'),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Send the results of the original query along with the changes from the browser to the server",(0,s.kt)("br",{parentName:"li"}),"Note that this requires the browser to store those original values so they can be returned to the server"),(0,s.kt)("li",{parentName:"ol"},"Create a new column in the table to be updated (e.g. row_version) that is incremented each time a change is made")),(0,s.kt)("p",null,"The first approach has the advantage that it doesn't need any special design changes to the tables but requires us to compare the results of the original query (sent from the browser) with the results of a new query executed before we perform the update."),(0,s.kt)("p",null,"The second method also requires the browser to send extra data but this time only the previous value of the row version which we can then compare to the current value of the row version obtained from a new query. This also requires general query endpoints from the results of which the user might want to update the data must now also send the row version to the browser so that it can be returned for the update."),(0,s.kt)("p",null,"The method you use will depend on a number of factors but most likely will be dictated by the coding standards of the organisation you work for."),(0,s.kt)("p",null,"Below is an example, with comments in the code, based on method 1. for the reservation checkin process given above. The process is shown in full, from the initial query through the change process to the database transaction. Alongside this there is an example of what might occur if a second user attempts to change the same data."),(0,s.kt)("p",null,"User A (the receptionist in our hotel) asks the customer for their name and issues a query via the endpoint ",(0,s.kt)("inlineCode",{parentName:"p"},"/customers/by_name/:name")," to retrieve their details. They then query the reservations table to get the corresponding reservation for today's date. This query returns the reservation details as an array of matching rows (in this case only one row) as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "id": 43,\n    "cust_id": 104,\n    "checkin_date": "2020-05-13",\n    "checkout_date": "2020-06-19",\n    "room_no": null,\n    "no_guests": 2,\n    "booking_date": "2020-06-05"\n  }\n]\nThe code that runs in user A\'s browser saves a copy of this data for use in the update request then populates the fields on the web page so that the user can check and update them.\n\n   Meanwhile user B has also queried this reservation and plans\n   to change the number of guests to 1. User B receives the same\n   JSON block as user A.\n\nUser A checks the details with the customer and asks if there are any changes they would like. The customer asks if it would be possible to stay two more nights. The receptionist checks the room bookings and agrees the change. User A now makes the room allocation and updates the room number on the screen - nothing is sent to the database yet.\n\n   User B has changed the number of guests in the reservation\n   but has not yet clicked Submit.\n\nUser A now hits the Submit button. The code in the browser now collates all the required information, the changes and the results from the original query, into a JSON structure and sends the request to the server.\n\nThis now requires a more complex JSON body - it must include both the assigned room no and the adjusted checkout date but also the unmodified data from the original query, for example:\n```js\n{\n  "original": {\n                "id": 43,\n                "cust_id": 104,\n                "checkin_date": "2020-05-13",\n                "checkout_date": "2020-06-19",\n                "room_no": null,\n                "no_guests": 2,\n                "booking_date": "2020-06-05"\n              },\n  "changes":  {\n              "room_no": 309,\n              "checkout_date": "2020-06-21"\n              }\n}\n')),(0,s.kt)("p",null,"Note that the JSON body now includes the results of the original query against the reservations table. We must check that the corresponding row (id = 43) still contains the same data (otherwise we can assume another user has changed it in the intervening period). Below is the endpoint we might use:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'app.put("/reservations/checkin/:id", function(req, res) {\n  const resId = req.params.id;\n  const resRoomNo = req.body.changes.room_no;    // NOTE: this now refers to req.body.changes.room_no\n  const resCheckout = req.body.changes.checkout_date;\n\n  //\n  // Function to compare two objects for equality of properties\n  // Note: this does not perform a true equality test but compares\n  //   attributes in \'a\' that also occur in \'b\'. Any attributes in\n  //   \'b\' that don\'t appear in \'a\' are not checked.\n  //\n  function objEqual (a, b) {\n    for (var item in a) {\n      if (a[item] != b[item]) {\n          return false\n      }\n    };\n  return true\n  }\n\n  //\n  // Here is the main part of the endpoint code - checking the original\n  // data is unchanged then applying the changes.\n  //\n\n  (async () => {\n    try {\n      let result;\n\n      const conn = await db.connect();\n      await conn.query("BEGIN TRANSACTION");\n      //\n      // Here we re-query the row to get the data to match against\n      // req.body.original. Notice that we use the FOR UPDATE option\n      // on the query to lock the row to prevent any further changes\n      // until we commit or rollback our transaction.\n      // If they are the same then proceed normally, otherwise\n      // return an error to the user\n      //\n      result = await conn.query(\n          "SELECT cust_id, checkin_date, checkout_date, room_no, no_guests, booking_date" +\n            " FROM reservations" +\n            " WHERE id = $1" +\n            " FOR UPDATE",    // Note - using the FOR UPDATE option\n          [resId]\n        ):\n      //\n      // Now use the objEqual function to compare the row with the\n      // data in req.body.original\n      //\n      if (objEqual(result.rows[0], req.body.original)) {\n        //\n        // Latest row = original, so now we are OK to continue...\n        //\n        if (resCheckout === undefined) {\n          await conn.query("UPDATE reservations" +\n                            " SET room_no = $2" +\n                            " WHERE id = $1", [resId, resRoomNo]);\n        } else {\n          await conn.query("UPDATE reservations" +\n                            " SET room_no = $2, checkout_date = $3" +\n                            " WHERE id = $1", [resId, resRoomNo, resCheckout]);\n        }\n        await conn.query("INSERT INTO invoices (res_id, total)" +\n                          " VALUES ($1, 0.0)", [resId]);\n        await conn.query("COMMIT");\n        conn.release();\n        res.status(200).send("Checkin completed successfully");\n        //\n        // By this point we\'ve completed the changes successfully\n        //\n      } else {\n        //\n        // Here if the row doesn\'t match the original\n        //\n        conn.query("ROLLBACK");\n        conn.release();\n        res.status(400).json({error: "Data modified by another user - please retry."});\n      }\n    } catch(err) {\n      //\n      // General error handling in the case of database errors\n      //\n      if (conn != null) {\n        conn.query("ROLLBACK");\n        conn.release();\n      }\n      res.status(500).json({error: err});\n    }\n  })();\n});\n')),(0,s.kt)("p",null,"That is doing a lot more work than the previous version of our checkin routine so it's rather more code. It is, however, a much more robust piece of code and is able to cope with multi-user activity that could break the previous version. For example, user B now clicks the Submit button, sending back the same original data. When this is checked against the current state of the row it no longer matches (room_no and checkout_date differ), however, so user B receives the message:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Data modified by another user - please retry.\n")),(0,s.kt)("p",null,"User B must restart their changes and resubmit if they still wish to make their change."),(0,s.kt)("p",null,"Just to recap, the sequence of events is as follows:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The user queries to get the data they need to complete the checkin process (e.g. customer and reservation details)"),(0,s.kt)("li",{parentName:"ol"},"The code in the browser saves the results of the query locally"),(0,s.kt)("li",{parentName:"ol"},"The user spends time completing the checkin details"),(0,s.kt)("li",{parentName:"ol"},"The user clicks the button to send the changes to the server, the browser also sends the original query results"),(0,s.kt)("li",{parentName:"ol"},"The server issues a query using the ",(0,s.kt)("inlineCode",{parentName:"li"},"FOR UPDATE")," option against the reservations table to ensure no other user has changed that reservation while our user was working. The row is locked."),(0,s.kt)("li",{parentName:"ol"},"If the results of the query at (5.) returns the same data as the original from (1.) - sent by the browser then we can continue with the update"),(0,s.kt)("li",{parentName:"ol"},"If the results are different then we abort the transaction and send a message to the user saying another user has changed the data")),(0,s.kt)("p",null,'The endpoint above uses an IIFE (Immediately Invoked Function Expression) to establish an "async" environment in which to use the "await" calls. Another way to use ',(0,s.kt)("inlineCode",{parentName:"p"},"async")," is in the endpoint callback (possibly more appropriately considered an event-handler)."),(0,s.kt)("p",null,"The endpoint would then start as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'app.put("/reservations/checkin/:id", async function(req, res) {\n  ...\n')),(0,s.kt)("p",null,"Note the use of ",(0,s.kt)("inlineCode",{parentName:"p"},"async")," before the callback function. This can also use an arrow function, written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'app.put("/reservations/checkin/:id", async (req, res) => {\n')),(0,s.kt)("p",null,"The rest of the code, excluding the IIFE, would remain the same. Here is the relevant part at the start of what was the IIFE (which has been commented out):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"  //\n  // Here is the main part of the endpoint code - checking the original\n  // data is unchanged then applying the changes.\n  //\n\n//  (async () => {    // This was the IIFE to allow use of await\n    try {\n      let result;\n      ...\n")),(0,s.kt)("p",null,"then the end of the IIFE is also removed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"      res.status(500).json({error: err});\n    }\n//  })();             // The end of the IIFE commented out\n});\n")),(0,s.kt)("p",null,"All the other code remains the same and the endpoint works as before."))}p.isMDXComponent=!0},32898:function(e,t,n){t.Z=n.p+"assets/images/change_conflict-f14e350fcc99a628d419e145260c3136.png"}}]);